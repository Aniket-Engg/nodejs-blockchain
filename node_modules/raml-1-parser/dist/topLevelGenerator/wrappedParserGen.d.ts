
import def = require("raml-definition-system");
import td = require("ts-model");
import nominals = def.rt.nominalTypes;
export declare class ParserGenerator {
    interfaceModule: td.TSAPIModule;
    implementationModule: td.TSAPIModule;
    processed: {
        [name: string]: def.IType;
    };
    processType(u: def.IType, generateConstructor?: boolean): void;
    private generateIsInstanceBody(classIdentifier);
    private generatePrimitivesAnnotations(u, interfaceModel, classModel);
    private annotableScalarProperties(u);
    private addInterfaceMethod(idcl, methodName, returnTypeName, comment?);
    private getExistingMethods(idcl, methodName);
    private addImplementationMethod(dcl, methodName, returnTypeName, body, comment?);
    private addImplementationSingleparamMethod(dcl, methodName, returnTypeName, paramName, paramType, body, comment?, isStatic?);
    private generateBody(x);
    private addHelperMethods(u, decl, isImpl?);
    private isVoid(tRef);
    private createTypeForModel(typeModel, method);
    extractSecondarySupertypes(type: def.IType): def.IType[];
    private typeMap;
    private createSetterMethodDecl(dcl, x);
    private createMethodDecl(dcl, x);
    private helperMethods;
    private helperSources;
    private ramlVersion;
    initHelpers(u: def.IType): void;
    getApiImportFile(): string;
    serializeInterfaceToString(): string;
    serializeImplementationToString(): string;
    serializeInterfaceImportsToString(): string;
    serializeInstanceofMethodsToString(): string;
    serializeImplementationImportsToString(): string;
    serializeLoadingMethods(): string;
    createFunctions(): string;
    createIsFragmentMethod(): string;
    nodeFactory(highLevelASTLocation: string, parserLocation: string): string;
}
export declare function def2Parser(...u: def.IType[]): ParserGenerator;
export declare function checkIfReference(u: nominals.ITypeDefinition): boolean;
